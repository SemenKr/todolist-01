// app/store.ts - Redux Store с автосохранением в localStorage

import { combineReducers, configureStore } from '@reduxjs/toolkit';
import { todolistsReducer } from '@/models/todolists/todolists-reducer';
import { tasksReducer } from '@/models/tasks/tasks-reucer';

// ═══════════════════════════════════════════════════════════════════════════
// КОНСТАНТЫ
// ═══════════════════════════════════════════════════════════════════════════

// Ключ для сохранения данных в localStorage браузера
const STORAGE_KEY = 'todoapp';

// ═══════════════════════════════════════════════════════════════════════════
// ОБЪЕДИНЕНИЕ РЕДЮСЕРОВ
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Объединяем все редюсеры приложения в один корневой редюсер
 *
 * Структура state:
 * {
 *   todolists: [...],  // массив списков задач
 *   tasks: {...}       // объект с задачами для каждого списка
 * }
 */
const rootReducer = combineReducers({
    todolists: todolistsReducer,  // Управляет списками задач
    tasks: tasksReducer,           // Управляет задачами внутри списков
});

// ═══════════════════════════════════════════════════════════════════════════
// ТИПЫ TYPESCRIPT
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Тип всего состояния приложения
 * TypeScript автоматически выводит типы из rootReducer
 *
 * Теперь в компонентах будет автодополнение:
 * const todolists = useSelector((state: RootState) => state.todolists)
 */
export type RootState = ReturnType<typeof rootReducer>;

// ═══════════════════════════════════════════════════════════════════════════
// ЗАГРУЗКА ДАННЫХ ИЗ LOCALSTORAGE
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Загружает сохранённое состояние из localStorage при запуске приложения
 *
 * @returns Сохранённый state или undefined (если данных нет или они повреждены)
 *
 * Пример работы:
 * - Первый запуск: нет данных → возвращает undefined → используется initialState
 * - Повторный запуск: есть данные → возвращает {todolists: [...], tasks: {...}}
 */
const loadState = (): RootState | undefined => {
    try {
        // Пытаемся получить сохранённую строку из localStorage
        const saved = localStorage.getItem(STORAGE_KEY);

        // Если данных нет - возвращаем undefined
        // Store будет создан с пустым initialState из редюсеров
        if (!saved) return undefined;

        // Преобразуем JSON-строку обратно в JavaScript объект
        // localStorage хранит только строки, поэтому нужен parse
        return JSON.parse(saved);

    } catch (error) {
        // Если что-то пошло не так (битые данные, ошибка парсинга):
        // - Возвращаем undefined
        // - Store создастся с чистым state
        console.error('Ошибка загрузки данных из localStorage:', error);
        return undefined;
    }
};

// ═══════════════════════════════════════════════════════════════════════════
// СОЗДАНИЕ REDUX STORE
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Создаём главный Redux Store приложения
 *
 * preloadedState - начальное состояние при создании store
 * Если loadState() вернёт данные, store создастся с ними
 * Если вернёт undefined, используется initialState из редюсеров
 */
export const store = configureStore({
    reducer: rootReducer,           // Наш объединённый редюсер
    preloadedState: loadState(),    // Загружаем сохранённые данные (если есть)
});

// ═══════════════════════════════════════════════════════════════════════════
// АВТОСОХРАНЕНИЕ В LOCALSTORAGE (МАГИЯ! ✨)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Переменная для хранения таймера debounce
 * Нужна, чтобы отменять предыдущее сохранение, если state изменился снова
 */
let timeout: NodeJS.Timeout;

/**
 * Подписываемся на все изменения в store
 * store.subscribe() вызывается КАЖДЫЙ РАЗ, когда state изменяется
 *
 * Работает так:
 * 1. User создаёт задачу → dispatch(action)
 * 2. Reducer обновляет state
 * 3. Эта функция вызывается автоматически
 * 4. Через 300мс данные сохраняются в localStorage
 */
store.subscribe(() => {

    // ───────────────────────────────────────────────────────────────────────
    // DEBOUNCE: Откладываем сохранение на 300 миллисекунд
    // ───────────────────────────────────────────────────────────────────────

    /**
     * Почему debounce?
     *
     * БЕЗ debounce:
     * User печатает "Hello" → 5 букв = 5 сохранений в localStorage
     * User добавляет 10 задач быстро → 10 сохранений подряд
     * = Тормоза и лишняя нагрузка 😱
     *
     * С debounce:
     * User печатает "Hello" → ждём 300мс после последней буквы → 1 сохранение ✅
     * User добавляет 10 задач → ждём 300мс после последней → 1 сохранение ✅
     * = Быстро и эффективно! 🚀
     */

    // Отменяем предыдущий таймер (если state изменился снова)
    clearTimeout(timeout);

    // Создаём новый таймер - сохранение через 300мс
    timeout = setTimeout(() => {

        try {
            // ─────────────────────────────────────────────────────────────────
            // СОХРАНЕНИЕ В LOCALSTORAGE
            // ─────────────────────────────────────────────────────────────────

            /**
             * 1. store.getState() - получаем весь текущий state
             *    Результат: { todolists: [...], tasks: {...} }
             *
             * 2. JSON.stringify() - превращаем объект в строку
             *    Результат: '{"todolists":[...],"tasks":{...}}'
             *    (localStorage хранит только строки!)
             *
             * 3. localStorage.setItem() - сохраняем строку в браузер
             *    Данные останутся даже после закрытия вкладки/браузера
             */
            localStorage.setItem(
                STORAGE_KEY,                        // Ключ: 'todoapp'
                JSON.stringify(store.getState())    // Значение: весь state как строка
            );

        } catch (error) {
            // Если что-то пошло не так (переполнение localStorage, ошибка доступа):
            // - Логируем ошибку
            // - Приложение продолжает работать (данные просто не сохранятся)
            console.error('Ошибка сохранения в localStorage:', error);
        }

    }, 300); // Задержка 300 миллисекунд (0.3 секунды)
});

// ═══════════════════════════════════════════════════════════════════════════
// ТИПЫ ДЛЯ TYPESCRIPT
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Тип для dispatch функций
 * Используется в хуке useAppDispatch для правильной типизации actions
 */
export type AppDispatch = typeof store.dispatch;

// ═══════════════════════════════════════════════════════════════════════════
// УТИЛИТЫ
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Функция для полной очистки данных приложения
 *
 * Использование:
 * <Button onClick={clearAppData}>Очистить всё</Button>
 *
 * Что происходит:
 * 1. Удаляем данные из localStorage
 * 2. Перезагружаем страницу
 * 3. loadState() вернёт undefined
 * 4. Приложение запустится с пустым state
 */
export const clearAppData = () => {
    localStorage.removeItem(STORAGE_KEY);  // Удаляем данные из браузера
    window.location.reload();              // Перезагружаем страницу
};

// ═══════════════════════════════════════════════════════════════════════════
// ИТОГОВАЯ СХЕМА РАБОТЫ
// ═══════════════════════════════════════════════════════════════════════════

/**
 * ПЕРВЫЙ ЗАПУСК:
 * ┌─────────────────────────────────────────────────────────────┐
 * │ 1. loadState() → нет данных → undefined                     │
 * │ 2. Store создаётся с пустым initialState                    │
 * │ 3. User создаёт todolist                                    │
 * │ 4. store.subscribe() → через 300мс → save to localStorage   │
 * │ 5. localStorage теперь хранит данные ✅                      │
 * └─────────────────────────────────────────────────────────────┘
 *
 * ПОВТОРНЫЙ ЗАПУСК:
 * ┌─────────────────────────────────────────────────────────────┐
 * │ 1. loadState() → есть данные → {todolists: [...], ...}     │
 * │ 2. Store создаётся с загруженными данными                   │
 * │ 3. User видит все свои списки и задачи! 🎉                  │
 * │ 4. User добавляет задачу                                    │
 * │ 5. store.subscribe() → обновляет localStorage               │
 * └─────────────────────────────────────────────────────────────┘
 *
 * ОЧИСТКА ДАННЫХ:
 * ┌─────────────────────────────────────────────────────────────┐
 * │ 1. clearAppData() → удаляет из localStorage                 │
 * │ 2. Перезагрузка страницы                                    │
 * │ 3. loadState() → undefined → чистый state                   │
 * └─────────────────────────────────────────────────────────────┘
 */
